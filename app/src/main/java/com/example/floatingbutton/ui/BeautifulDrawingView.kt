package com.example.floatingbutton.ui

import android.animation.ValueAnimator
import android.content.Context
import android.graphics.*
import android.util.AttributeSet
import android.view.MotionEvent
import android.view.View
import android.view.animation.DecelerateInterpolator
import kotlin.math.*

/**
 * üé® Beautiful Drawing View - Interface de desenho suave e elegante
 * 
 * Caracter√≠sticas:
 * - Desenho suave como caneta do Paint
 * - Efeitos visuais modernos (glow, sombra, gradiente)
 * - Anima√ß√µes fluidas
 * - Detec√ß√£o inteligente de √°rea
 */
class BeautifulDrawingView @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = 0
) : View(context, attrs, defStyleAttr) {

    companion object {
        private const val TAG = "BeautifulDrawingView"
        private const val STROKE_WIDTH = 8f
        private const val GLOW_RADIUS = 20f
        private const val TOUCH_TOLERANCE = 4f
        private const val ANIMATION_DURATION = 300L
    }

    // üé® Pontos do desenho
    private val drawPoints = mutableListOf<PointF>()
    private val smoothPath = Path()
    private var currentX = 0f
    private var currentY = 0f
    
    // üé® Estados de desenho
    private var isDrawing = false
    private var isAnimatingComplete = false
    
    // üé® Paints para efeitos visuais
    private val strokePaint = Paint().apply {
        isAntiAlias = true
        style = Paint.Style.STROKE
        strokeWidth = STROKE_WIDTH
        strokeCap = Paint.Cap.ROUND
        strokeJoin = Paint.Join.ROUND
        color = Color.parseColor("#4285F4") // Azul Google
    }
    
    private val glowPaint = Paint().apply {
        isAntiAlias = true
        style = Paint.Style.STROKE
        strokeWidth = STROKE_WIDTH + 4f
        strokeCap = Paint.Cap.ROUND
        strokeJoin = Paint.Join.ROUND
        color = Color.parseColor("#804285F4") // Azul com transpar√™ncia
        maskFilter = BlurMaskFilter(GLOW_RADIUS, BlurMaskFilter.Blur.NORMAL)
    }
    
    private val overlayPaint = Paint().apply {
        color = Color.parseColor("#80000000") // Preto semi-transparente
        isAntiAlias = true
    }
    
    private val selectionPaint = Paint().apply {
        color = Color.parseColor("#204285F4") // Azul muito transparente
        isAntiAlias = true
    }
    
    // üé® Anima√ß√£o de conclus√£o
    private var completionAnimator: ValueAnimator? = null
    private var animationProgress = 0f
    
    // üì± Callbacks
    private var onDrawingStartListener: (() -> Unit)? = null
    private var onDrawingProgressListener: ((List<PointF>) -> Unit)? = null
    private var onDrawingCompleteListener: ((Path, List<PointF>, RectF) -> Unit)? = null

    init {
        // Habilita desenho de sombras/blur
        setLayerType(LAYER_TYPE_SOFTWARE, null)
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
        
        if (drawPoints.isNotEmpty()) {
            updateSmoothPath()
            
            if (isDrawing) {
                // üé® Enquanto desenha: apenas a linha suave com glow
                drawStrokeWithGlow(canvas)
            } else if (isAnimatingComplete) {
                // üé® Anima√ß√£o de conclus√£o
                drawCompletionAnimation(canvas)
            } else {
                // üé® Desenho finalizado: overlay + sele√ß√£o + linha
                drawFinalSelection(canvas)
            }
        }
    }

    /**
     * üé® Desenha apenas o tra√ßo com efeito glow (durante o desenho)
     */
    private fun drawStrokeWithGlow(canvas: Canvas) {
        // Glow effect
        canvas.drawPath(smoothPath, glowPaint)
        // Main stroke
        canvas.drawPath(smoothPath, strokePaint)
    }

    /**
     * üé® Desenha a anima√ß√£o de conclus√£o
     */
    private fun drawCompletionAnimation(canvas: Canvas) {
        val animatedAlpha = (255 * animationProgress).toInt()
        
        // Overlay animado
        val animatedOverlay = Paint(overlayPaint).apply {
            alpha = animatedAlpha
        }
        canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), animatedOverlay)
        
        // √Årea selecionada (transparente) com anima√ß√£o
        if (drawPoints.size > 2) {
            val closedPath = Path(smoothPath)
            closedPath.close()
            
            val save = canvas.save()
            canvas.clipPath(closedPath)
            canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR)
            canvas.restoreToCount(save)
            
            // Preenchimento sutil animado
            val animatedSelection = Paint(selectionPaint).apply {
                alpha = (128 * animationProgress).toInt()
            }
            canvas.drawPath(closedPath, animatedSelection)
        }
        
        // Linha principal sempre vis√≠vel
        canvas.drawPath(smoothPath, glowPaint)
        canvas.drawPath(smoothPath, strokePaint)
    }

    /**
     * üé® Desenha a sele√ß√£o final
     */
    private fun drawFinalSelection(canvas: Canvas) {
        // Overlay escuro
        canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), overlayPaint)
        
        if (drawPoints.size > 2) {
            val closedPath = Path(smoothPath)
            closedPath.close()
            
            // Remove overlay da √°rea selecionada
            val save = canvas.save()
            canvas.clipPath(closedPath)
            canvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR)
            canvas.restoreToCount(save)
            
            // Preenchimento sutil na √°rea selecionada
            canvas.drawPath(closedPath, selectionPaint)
        }
        
        // Linha principal com glow
        canvas.drawPath(smoothPath, glowPaint)
        canvas.drawPath(smoothPath, strokePaint)
    }

    /**
     * üé® Atualiza o path suavizado usando curvas B√©zier
     */
    private fun updateSmoothPath() {
        if (drawPoints.size < 2) return
        
        smoothPath.reset()
        smoothPath.moveTo(drawPoints[0].x, drawPoints[0].y)
        
        for (i in 1 until drawPoints.size) {
            val point = drawPoints[i]
            
            if (i == 1) {
                // Primeira curva
                val midX = (drawPoints[0].x + point.x) / 2f
                val midY = (drawPoints[0].y + point.y) / 2f
                smoothPath.quadTo(drawPoints[0].x, drawPoints[0].y, midX, midY)
            } else {
                // Curvas suaves entre pontos
                val prevPoint = drawPoints[i - 1]
                val midX = (prevPoint.x + point.x) / 2f
                val midY = (prevPoint.y + point.y) / 2f
                smoothPath.quadTo(prevPoint.x, prevPoint.y, midX, midY)
            }
        }
        
        // Linha at√© o √∫ltimo ponto
        if (drawPoints.size > 1) {
            val lastPoint = drawPoints.last()
            smoothPath.lineTo(lastPoint.x, lastPoint.y)
        }
    }

    override fun onTouchEvent(event: MotionEvent): Boolean {
        val x = event.x
        val y = event.y

        when (event.action) {
            MotionEvent.ACTION_DOWN -> {
                startDrawing(x, y)
                return true
            }
            MotionEvent.ACTION_MOVE -> {
                continueDrawing(x, y)
                return true
            }
            MotionEvent.ACTION_UP -> {
                finishDrawing()
                return true
            }
        }
        return false
    }

    /**
     * üé® Inicia o desenho
     */
    private fun startDrawing(x: Float, y: Float) {
        clearDrawing()
        isDrawing = true
        currentX = x
        currentY = y
        
        drawPoints.add(PointF(x, y))
        onDrawingStartListener?.invoke()
        invalidate()
    }

    /**
     * üé® Continua o desenho
     */
    private fun continueDrawing(x: Float, y: Float) {
        if (!isDrawing) return
        
        val dx = abs(x - currentX)
        val dy = abs(y - currentY)
        
        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
            drawPoints.add(PointF(x, y))
            currentX = x
            currentY = y
            
            onDrawingProgressListener?.invoke(drawPoints.toList())
            invalidate()
        }
    }

    /**
     * üé® Finaliza o desenho com anima√ß√£o suave
     */
    private fun finishDrawing() {
        if (!isDrawing || drawPoints.size < 3) {
            clearDrawing()
            return
        }
        
        isDrawing = false
        
        // Inicia anima√ß√£o de conclus√£o
        startCompletionAnimation()
    }

    /**
     * ‚ú® Inicia anima√ß√£o suave de conclus√£o
     */
    private fun startCompletionAnimation() {
        isAnimatingComplete = true
        
        completionAnimator?.cancel()
        completionAnimator = ValueAnimator.ofFloat(0f, 1f).apply {
            duration = ANIMATION_DURATION
            interpolator = DecelerateInterpolator()
            
            addUpdateListener { animator ->
                animationProgress = animator.animatedValue as Float
                invalidate()
            }
            
            addListener(object : android.animation.AnimatorListenerAdapter() {
                override fun onAnimationEnd(animation: android.animation.Animator) {
                    isAnimatingComplete = false
                    
                    // Calcula bounds da √°rea selecionada
                    val bounds = calculateDrawingBounds()
                    
                    // Notifica conclus√£o
                    onDrawingCompleteListener?.invoke(smoothPath, drawPoints.toList(), bounds)
                    invalidate()
                }
            })
            
            start()
        }
    }

    /**
     * üìê Calcula os bounds da √°rea desenhada
     */
    private fun calculateDrawingBounds(): RectF {
        if (drawPoints.isEmpty()) return RectF()
        
        var minX = drawPoints[0].x
        var maxX = drawPoints[0].x
        var minY = drawPoints[0].y
        var maxY = drawPoints[0].y
        
        for (point in drawPoints) {
            minX = min(minX, point.x)
            maxX = max(maxX, point.x)
            minY = min(minY, point.y)
            maxY = max(maxY, point.y)
        }
        
        return RectF(minX, minY, maxX, maxY)
    }

    /**
     * üßπ Limpa o desenho
     */
    fun clearDrawing() {
        drawPoints.clear()
        smoothPath.reset()
        isDrawing = false
        isAnimatingComplete = false
        completionAnimator?.cancel()
        animationProgress = 0f
        invalidate()
    }

    /**
     * üì± Setters para callbacks
     */
    fun setOnDrawingStartListener(listener: () -> Unit) {
        onDrawingStartListener = listener
    }

    fun setOnDrawingProgressListener(listener: (List<PointF>) -> Unit) {
        onDrawingProgressListener = listener
    }

    fun setOnDrawingCompleteListener(listener: (Path, List<PointF>, RectF) -> Unit) {
        onDrawingCompleteListener = listener
    }

    /**
     * üéØ Obt√©m bounds da √°rea desenhada
     */
    fun getDrawingBounds(): RectF = calculateDrawingBounds()

    /**
     * üé® Verifica se tem desenho ativo
     */
    fun hasDrawing(): Boolean = drawPoints.isNotEmpty()
}
